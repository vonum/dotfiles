autoload -Uz colors && colors
setopt prompt_subst

PROMPT_SYMBOL="⟩"
COMMAND_START_SYMBOL="Ξ"

GIT_NEW_FILES_ICON="+"
GIT_MODIFIED_FILES_ICON="∘"
GIT_REMOVED_FILES_ICON="-"

function is_git_repo() {
  [ -e "$PWD/.git" ]
}

function is_clean_git_repo() {
  [[ ! -z $(git status | grep "nothing to commit") ]]
}

function prompt_start_symbol() {
  echo "%B"
  if [ $? -eq 0 ]; then
    echo -n "%F{magenta}$PROMPT_SYMBOL%f"
  else
    echo -n "%F{red}$PROMPT_SYMBOL%f"
  fi
  echo "%b"
}

function command_start_symbol() {
  echo "%F{yellow}%B$COMMAND_START_SYMBOL%b%f"
}

function prompt_git_branch() {
  if is_git_repo; then
    local branch=$(git rev-parse --abbrev-ref HEAD)

    branch_suffix=""

    if ! is_clean_git_repo then; then
      branch_suffix="*"
    fi

    echo -n "%F{243}$branch$branch_suffix%f"
  fi
}

function prompt_directory() {
  echo "%F{42}%B%c%b%f"
}

function prompt_jobs() {
  count=$( ( jobs ) | wc -l)

  ((count)) && echo -n " %F{215}{${count}}%f"
}

function git_new_files_icon() {
  if [[ ! -z $(g st | awk '$1 == "??"') ]]; then
    echo "%F{green}%B$GIT_NEW_FILES_ICON%b%f"
  fi
}

function git_modified_files_icon() {
  if [[ ! -z $(g st | awk '$1 == "M"') ]]; then
    echo "%F{yellow}%B$GIT_MODIFIED_FILES_ICON%b%f"
  fi
}

function git_removed_files_icon() {
  if [[ ! -z $(g st | awk '$1 == "D"') ]]; then
    echo "%F{red}%B$GIT_REMOVED_FILES_ICON%b%f"
  fi
}

function right_prompt_start() {
  if ! is_clean_git_repo; then
    echo "%F{cyan}%B[%b%f"
  fi
}

function right_prompt_end() {
  if ! is_clean_git_repo; then
    echo "%F{cyan}%B]%b%f"
  fi
}

export PROMPT='$(prompt_start_symbol) $(prompt_directory)$(prompt_jobs) $(prompt_git_branch) $(command_start_symbol) '

if is_git_repo; then
  export RPROMPT='$(right_prompt_start)$(git_new_files_icon)$(git_modified_files_icon)$(git_removed_files_icon)$(right_prompt_end)'
fi
