autoload -Uz colors && colors
setopt prompt_subst

PROMPT_SYMBOL="⟩"
COMMAND_START_SYMBOL="Ξ"

GIT_NEW_FILES_ICON="+"
GIT_MODIFIED_FILES_ICON="∘"
GIT_REMOVED_FILES_ICON="-"

function is_git_repo() {
  [ -e "$PWD/.git" ]
}

function is_clean_git_repo() {
  [[ ! -z $(git status | grep "nothing to commit") ]]
}

function prompt_start_symbol() {
  if [ $? -eq 0 ]; then
    echo -n "%F{135}%B$PROMPT_SYMBOL%b%f"
  else
    echo -n "%F{203}%B$PROMPT_SYMBOL%b%f"
  fi
}

function command_start_symbol() {
  echo "%F{226}%B$COMMAND_START_SYMBOL%b%f"
}

function git_branch() {
  if is_git_repo; then
    local branch=$(git rev-parse --abbrev-ref HEAD)

    branch_suffix=""

    if ! is_clean_git_repo then; then
      branch_suffix="*"
    fi

    echo -n "%F{243}$branch$branch_suffix%f"
  fi
}

function directory() {
  echo "%F{42}%B%c%b%f"
}

function background_jobs() {
  count=$( ( jobs ) | wc -l)

  ((count)) && echo -n " %F{215}{${count}}%f"
}

function git_new_files_icon() {
  if [[ ! -z $(g st | awk '$1 == "??"') ]]; then
    echo "%F{076}%B$GIT_NEW_FILES_ICON%b%f"
  fi
}

function git_modified_files_icon() {
  if [[ ! -z $(g st | awk '$1 == "M"') ]]; then
    echo "%F{184}%B$GIT_MODIFIED_FILES_ICON%b%f"
  fi
}

function git_removed_files_icon() {
  if [[ ! -z $(g st | awk '$1 == "D"') ]]; then
    echo "%F{196}%B$GIT_REMOVED_FILES_ICON%b%f"
  fi
}

function right_prompt_start() {
  if ! is_clean_git_repo; then
    echo "%F{039}%B[%b%f"
  fi
}

function right_prompt_end() {
  if ! is_clean_git_repo; then
    echo "%F{039}%B]%b%f"
  fi
}

function git_files_status() {
  if is_git_repo; then
    echo "$(right_prompt_start)$(git_new_files_icon)$(git_modified_files_icon)$(git_removed_files_icon)$(right_prompt_end)"
  fi
}

export PROMPT='$(prompt_start_symbol) $(directory)$(background_jobs) $(git_branch) $(command_start_symbol) '

export RPROMPT='$(git_files_status)'
